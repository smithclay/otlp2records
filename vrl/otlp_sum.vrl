# @schema sum
# @description OTLP sum metrics flattened for Arrow RecordBatch
#
# timestamp: timestamp, required, "Observation time in milliseconds"
# start_timestamp: int64, "Start time in milliseconds"
# metric_name: string, required, "Metric name"
# metric_description: string, "Metric description"
# metric_unit: string, "Unit (e.g., ms, bytes, 1)"
# value: float64, required, "Metric value"
# service_name: string, required, "Service name from resource"
# service_namespace: string
# service_instance_id: string
# resource_attributes: json, "Resource attributes blob"
# scope_name: string, "Instrumentation scope name"
# scope_version: string, "Instrumentation scope version"
# scope_attributes: json, "Scope attributes blob"
# metric_attributes: json, "Data point attributes blob"
# flags: int32, "Data point flags"
# exemplars_json: json, "Exemplars with trace context"
# aggregation_temporality: int32, required, "1=delta, 2=cumulative"
# is_monotonic: bool, required, "True for counters"
# @end

# vrl/otlp_sum.vrl - OTLP sum metrics -> flat metric event
# Note: Records are pre-partitioned by _metric_type in Rust before reaching VRL

# Timestamps (nanoseconds -> milliseconds)
.timestamp = nanos_to_micros(.time_unix_nano)
.start_timestamp = nanos_to_millis(.start_time_unix_nano)

# Metric metadata (default to empty string)
.metric_name = string_or_null(.metric_name)
if .metric_name == null { .metric_name = "" }
.metric_description = string_or_null(.metric_description)
if .metric_description == null { .metric_description = "" }
.metric_unit = string_or_null(.metric_unit)
if .metric_unit == null { .metric_unit = "" }

# Value is already set by decoder

# Service info from resource attributes
.service_name = get_attr(.resource.attributes, "service.name", "unknown")
.service_namespace = get_attr(.resource.attributes, "service.namespace")
.service_instance_id = get_attr(.resource.attributes, "service.instance.id")

# Attribute blobs as JSON
.resource_attributes = json_or_null(.resource.attributes)
.scope_name = string_or_null(.scope.name)
.scope_version = string_or_null(.scope.version)
.scope_attributes = json_or_null(.scope.attributes)
.metric_attributes = json_or_null(.attributes)
.exemplars_json = json_or_null(.exemplars)

# Flags and sum-specific fields
.flags = int_or_default(.flags, 0)
.aggregation_temporality = int_or_default(.aggregation_temporality, 0)
if .is_monotonic == null { .is_monotonic = false }

# Clean up nested structures
.time_unix_nano = null
.start_time_unix_nano = null
.resource = null
.scope = null
.attributes = null
.exemplars = null
._metric_type = null

# Routing
._table = "sum"
